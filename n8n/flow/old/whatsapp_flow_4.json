{
  "name": "WhatsApp Commerce - Flow 4: Product Handling",
  "nodes": [
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const items = $input.all();\nconst results = [];\nfor (const item of items) {\n    const session = item.json; \n    const categories = session.categories || []; \n    const customer = {\n        tier: session.customer_tier || 'new',\n        preferences: (session.context_data && typeof session.context_data === 'string' ? JSON.parse(session.context_data) : session.context_data || {}).preferredCategories || []\n    };\n    if (categories.length === 0) {\n        const response = {\n            messageType: 'text',\n            text: 'üòî *No hay productos disponibles*\\n\\nEn este momento no tenemos productos en stock. Nuestro equipo est√° trabajando para reponer el inventario.\\n\\nüìû ¬øNecesitas algo urgente?',\n            quickReplies: [\n                { id: 'contact_support', title: 'üë§ Contactar Soporte' },\n                { id: 'notify_restock', title: 'üîî Avisar Cuando Haya Stock' },\n                { id: 'emergency_delivery', title: 'üö® Entrega de Emergencia' }\n            ]\n        };\n        results.push({\n            json: { \n                ...session, \n                responseReady: true, \n                whatsappResponse: response,\n                sessionUpdate: {\n                    session_state: 'no_products_available',\n                    context_data: JSON.stringify({\n                        ...(session.context_data && typeof session.context_data === 'string' ? JSON.parse(session.context_data) : session.context_data || {}),\n                        noProductsAt: new Date().toISOString()\n                    })\n                }\n            }\n        });\n        continue;\n    }\n    const totalProducts = categories.reduce((sum, cat) => sum + (cat.product_count || 0), 0);\n    const totalOffers = categories.reduce((sum, cat) => sum + (cat.offers_count || 0), 0);\n    let mainMessage = '';\n    switch (customer.tier) {\n        case 'vip': mainMessage = `üëë *Bienvenido Cliente VIP*\\n\\nüõí Tenemos ${totalProducts} productos exclusivos esper√°ndote`; break;\n        case 'regular': mainMessage = `‚≠ê *Cliente Frecuente*\\n\\nüõí ${totalProducts} productos disponibles con precios especiales para ti`; break;\n        default: mainMessage = `üõí *Nuestras Categor√≠as*\\n\\nüì¶ ${totalProducts} productos frescos disponibles`;\n    }\n    if (totalOffers > 0) {\n        mainMessage += `\\nüè∑Ô∏è ${totalOffers} productos en oferta especial`;\n        if (customer.tier === 'vip') mainMessage += ` + descuento VIP adicional`;\n    }\n    const now = new Date();\n    const hour = now.getHours();\n    if (hour >= 12 && hour <= 14) mainMessage += `\\nüçΩÔ∏è *Especial almuerzo:* Ideas r√°pidas disponibles`;\n    else if (hour >= 19 && hour <= 21) mainMessage += `\\nüåô *Especial cena:* Ingredientes frescos para una cena perfecta`;\n    mainMessage += `\\n\\nüîç *Selecciona una categor√≠a para explorar:*`;\n    const categoryRows = categories.slice(0, 10).map(cat => {\n        let description = `${cat.product_count || 0} productos`;\n        if ((cat.offers_count || 0) > 0) description += ` ‚Ä¢ ${cat.offers_count} ofertas`;\n        if (description.length > 72) description = description.substring(0, 69) + '...';\n        return { id: `category_${cat.id}`, title: `${cat.icon_emoji || 'üìÅ'} ${cat.name}`, description: description };\n    });\n    const listSections = [];\n    if (categories.length <= 8) listSections.push({ title: 'Todas las Categor√≠as', rows: categoryRows });\n    else {\n        listSections.push({ title: 'Categor√≠as Principales', rows: categoryRows.slice(0, 6) });\n        if (categoryRows.length > 6) listSections.push({ title: 'M√°s Categor√≠as', rows: categoryRows.slice(6, 10) });\n    }\n    if (categories.length > 10) listSections.push({ title: 'Opciones Adicionales', rows: [{ id: 'view_all_categories', title: 'üìã Ver Todas las Categor√≠as', description: `${categories.length - 10} categor√≠as adicionales` }] });\n    let footerText = (totalOffers > 0) ? `üéâ ${totalOffers} productos en oferta especial` : 'Productos frescos y de calidad garantizada';\n    if (customer.tier === 'vip' && totalOffers > 0) footerText += ' + beneficios VIP';\n    footerText += (hour >= 8 && hour <= 22) ? ' ‚Ä¢ Entrega en 45-60 min' : ' ‚Ä¢ Pedidos desde las 8:00 AM';\n    const response = { messageType: 'interactive', interactiveType: 'list', text: mainMessage, buttonText: 'Ver Categor√≠as', listSections: listSections, footerText: footerText };\n    results.push({\n        json: {\n            ...session,\n            responseReady: true,\n            whatsappResponse: response,\n            sessionUpdate: {\n                session_state: 'Browse_categories',\n                context_data: JSON.stringify({\n                    ...(session.context_data && typeof session.context_data === 'string' ? JSON.parse(session.context_data) : session.context_data || {}),\n                    categoriesShown: categories.map(c => ({ id: c.id, name: c.name, productCount: c.product_count, offersCount: c.offers_count })),\n                    lastCategoryBrowse: new Date().toISOString(),\n                    totalProductsAvailable: totalProducts,\n                    totalOffersAvailable: totalOffers,\n                    BrowseContext: { customerTier: customer.tier, timeOfDay: hour < 12 ? 'morning' : hour < 18 ? 'afternoon' : 'evening' }\n                })\n            }\n        }\n    });\n}\nreturn results;"
      },
      "id": "node_20_format_categories",
      "name": "Format Categories (Nodo 20)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [250, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const session = $input.item.json;\nconst customerId = session.customer_phone; \nasync function predictNextProducts(customerId) { \n  \n  return ['predicted_product_1', 'predicted_product_2']; \n}\nasync function predictCartAbandonment(sessionData) { \n  \n  return Math.random(); \n}\n\nconst mlPredictions = {};\nmlPredictions.nextProducts = await predictNextProducts(customerId);\nmlPredictions.cartAbandonmentProbability = await predictCartAbandonment(session);\n\nif (mlPredictions.cartAbandonmentProbability > 0.7) {\n  \n  console.log('High cart abandonment probability. Trigger retention strategy.');\n}\n\nreturn { ...session, mlPredictions };"
      },
      "id": "ml_predictor_node_f4",
      "name": "ML Predictor",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [350, 450]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const items = $input.all();\nconst results = [];\nfor (const item of items) {\n    const session = item.json;\n    const entities = session.extractedEntities || {};\n    const intent = session.detectedIntent;\n    const messageText = (session.originalMessageText || '').toLowerCase();\n    let searchParams = {\n        productName: entities.productName || '',\n        category: entities.category || '',\n        priceRange: entities.priceRange,\n        urgency: entities.urgency || 'media',\n        brand: null,\n        size: null,\n        preferences: [],\n        searchType: 'general',\n        filters: {}\n    };\n    switch (intent) {\n        case 'VIEW_PRODUCT_DETAILS': searchParams.searchType = 'product_details'; searchParams.includeFullDetails = true; searchParams.includeSimilar = true; break;\n        case 'AVAILABILITY_CHECK': searchParams.searchType = 'stock_check'; searchParams.prioritizeAvailable = true; searchParams.includeAlternatives = true; break;\n        case 'PRICE_INQUIRY': searchParams.searchType = 'price_compare'; searchParams.showPriceComparison = true; searchParams.includeBudgetOptions = true; break;\n        case 'SEARCH_PRODUCTS': case 'ADD_TO_CART':\n            if (searchParams.productName) searchParams.searchType = 'specific_product';\n            else if (searchParams.category) searchParams.searchType = 'category_browse';\n            else searchParams.searchType = 'general_search';\n            break;\n        default: searchParams.searchType = 'featured_products';\n    }\n    const knownBrands = ['coca cola', 'pepsi', 'sprite', 'fanta', 'la seren√≠sima', 'sancor', 'tregar', 'milkaut', 'arcor', 'bagley', 'terrabusi', 'don satur', 'marolio', 'sehr', 'molinos', 'luchetti', 'hellmanns', 'natura', 'skippy', 'danica'];\n    const mentionedBrand = knownBrands.find(brand => messageText.includes(brand) || messageText.includes(brand.replace(/\\s+/g, '')));\n    if (mentionedBrand) { searchParams.brand = mentionedBrand; searchParams.filters.brand = mentionedBrand; }\n    const sizePatterns = [ /(\\d+(?:\\.\\d+)?)\\s*(kg|kilos?|gr|gramos?)/i, /(\\d+(?:\\.\\d+)?)\\s*(ml|mililitros?|l|litros?)/i, /(\\d+)\\s*(unidades?|u|piezas?)/i, /(chico|peque√±o|small)/i, /(mediano|medio|medium|m)/i, /(grande|large|l|familiar)/i ];\n    for (const pattern of sizePatterns) {\n        const match = messageText.match(pattern);\n        if (match) { searchParams.size = match[2] ? { amount: parseFloat(match[1]), unit: match[2].toLowerCase() } : { descriptor: match[1].toLowerCase() }; searchParams.filters.size = searchParams.size; break; }\n    }\n    const preferencePatterns = { 'organic': /org√°nico|organico|ecol√≥gico|bio\\b/i, 'light': /light|diet|bajo en calor√≠as|sin az√∫car|sin azucar/i, 'sugar_free': /sin az√∫car|sin azucar|libre de az√∫car|sugar free/i, 'gluten_free': /sin gluten|libre de gluten|cel√≠aco|celiaco|gluten free/i, 'lactose_free': /sin lactosa|libre de lactosa|lactose free/i, 'integral': /integral|whole grain|grano entero/i, 'skim': /descremad|desnatad|skim/i, 'low_sodium': /bajo en sodio|sin sal|low sodium/i, 'vegan': /vegano|vegan|plant based/i, 'kosher': /kosher|kasher/i };\n    for (const [pref, pattern] of Object.entries(preferencePatterns)) { if (pattern.test(messageText)) searchParams.preferences.push(pref); }\n    const now = new Date();\n    const hour = now.getHours();\n    const dayOfWeek = now.getDay();\n    if (hour >= 12 && hour <= 14 && !searchParams.productName) { searchParams.contextualSuggestions = ['comida r√°pida', 'ensaladas', 'sandwiches']; searchParams.mealTime = 'lunch';}\n    else if (hour >= 19 && hour <= 21 && !searchParams.productName) { searchParams.contextualSuggestions = ['ingredientes cena', 'comida familiar']; searchParams.mealTime = 'dinner'; }\n    const urgencyWords = ['urgente', 'r√°pido', 'ya', 'ahora', 'pronto', 'inmediato'];\n    if (urgencyWords.some(word => messageText.includes(word)) || entities.urgency === 'alta') { searchParams.urgency = 'alta'; searchParams.prioritizeInStock = true; searchParams.suggestAlternatives = true; }\n    switch (searchParams.searchType) {\n        case 'product_details': searchParams.limit = 1; break;\n        case 'specific_product': searchParams.limit = 15; break;\n        case 'category_browse': searchParams.limit = 20; break;\n        case 'price_compare': searchParams.limit = 10; searchParams.orderBy = 'price'; break;\n        default: searchParams.limit = 12;\n    }\n    if (searchParams.urgency === 'alta') searchParams.orderBy = 'stock_desc,price_asc';\n    else searchParams.orderBy = 'relevance_desc,popularity_desc';\n    results.push({ json: { ...session, searchParams: searchParams, needsProductSearch: true, searchAnalysis: { originalText: session.originalMessageText, detectedBrand: mentionedBrand, detectedSize: searchParams.size, detectedPreferences: searchParams.preferences, urgencyLevel: searchParams.urgency, contextualTime: { hour: hour, mealTime: searchParams.mealTime, dayOfWeek: dayOfWeek } } } });\n}\nreturn results;"
      },
      "id": "node_21_prepare_product_search",
      "name": "Prepare Product Search (Nodo 21)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH search_config AS (\n    SELECT \n        '{{$json.searchParams.productName}}' as search_term,\n        '{{$json.searchParams.category}}' as search_category,\n        '{{$json.searchParams.brand}}' as search_brand,\n        '{{$json.searchParams.searchType}}' as search_type,\n        '{{$json.searchParams.urgency}}' as urgency_level,\n        COALESCE(('{{$json.searchParams.filters.maxPrice}}')::decimal, 999999) as max_price,\n        COALESCE(('{{$json.searchParams.filters.minPrice}}')::decimal, 0) as min_price,\n        {{$json.searchParams.limit}} as result_limit\n),\nproduct_search_base AS (\n    SELECT \n        p.id, p.name, p.description, p.price, p.original_price, p.stock_quantity,\n        p.image_url, p.brand, p.weight_value, p.weight_unit, p.discount_percentage,\n        p.is_featured, p.popularity_score, p.meta_keywords,\n        c.name as category_name, c.icon_emoji as category_icon,\n        v.search_vector,\n        sc.search_term, sc.search_category, sc.search_brand, sc.search_type, sc.urgency_level\n    FROM product_search_view v \n    JOIN products p ON v.id = p.id\n    JOIN categories c ON p.category_id = c.id\n    CROSS JOIN search_config sc\n    WHERE p.price BETWEEN sc.min_price AND sc.max_price\n    AND (CASE sc.search_type\n            WHEN 'specific_product' THEN (sc.search_term != '' AND (v.search_vector @@ plainto_tsquery('spanish', sc.search_term) OR p.brand ILIKE '%' || sc.search_term || '%'))\n            WHEN 'category_browse' THEN (sc.search_category != '' AND c.name ILIKE '%' || sc.search_category || '%')\n            WHEN 'product_details' THEN (sc.search_term != '' AND p.name ILIKE '%' || sc.search_term || '%')\n            WHEN 'price_compare' THEN (sc.search_term != '' AND (v.search_vector @@ plainto_tsquery('spanish', sc.search_term)))\n            WHEN 'stock_check' THEN (sc.search_term != '' AND (v.search_vector @@ plainto_tsquery('spanish', sc.search_term) OR p.brand ILIKE '%' || sc.search_term || '%'))\n            ELSE (p.is_featured = true OR p.popularity_score > 5)\n        END)\n    AND (sc.search_brand = '' OR p.brand ILIKE '%' || sc.search_brand || '%')\n),\nproduct_search_scored AS (\n    SELECT psb.*,\n        (ts_rank(psb.search_vector, plainto_tsquery('spanish', psb.search_term)) * 10) +\n        (CASE WHEN psb.search_brand != '' AND LOWER(psb.brand) = LOWER(psb.search_brand) THEN 12 WHEN psb.search_brand != '' AND psb.brand ILIKE '%' || psb.search_brand || '%' THEN 8 ELSE 0 END) +\n        (CASE WHEN psb.search_category != '' AND psb.category_name ILIKE '%' || psb.search_category || '%' THEN 8 ELSE 0 END) +\n        (CASE WHEN psb.is_featured = true THEN 4 ELSE 0 END) + (CASE WHEN psb.discount_percentage > 0 THEN 3 ELSE 0 END) + (CASE WHEN psb.discount_percentage >= 20 THEN 2 ELSE 0 END) +\n        (CASE WHEN psb.urgency_level = 'alta' AND psb.stock_quantity > 20 THEN 3 WHEN psb.stock_quantity > 0 THEN 1 ELSE -5 END) +\n        LEAST(psb.popularity_score / 10.0, 5) as relevance_score,\n        CASE WHEN psb.stock_quantity = 0 THEN 'sin_stock' WHEN psb.stock_quantity <= p.min_stock_alert THEN 'poco_stock' WHEN psb.stock_quantity > 50 THEN 'abundante_stock' ELSE 'stock_normal' END as stock_status,\n        CASE WHEN psb.weight_unit IN ('kg', 'l') AND psb.weight_value > 0 THEN psb.price / psb.weight_value WHEN psb.weight_unit IN ('g', 'ml') AND psb.weight_value > 0 THEN psb.price / (psb.weight_value / 1000) ELSE psb.price END as price_per_standard_unit,\n        LAG(psb.price) OVER (PARTITION BY psb.category_id ORDER BY psb.price) as prev_price_in_category,\n        LEAD(psb.price) OVER (PARTITION BY psb.category_id ORDER BY psb.price) as next_price_in_category,\n        (SELECT STRING_AGG(p2.name, ', ' ORDER BY p2.popularity_score DESC) FROM products p2 WHERE p2.category_id = psb.category_id AND p2.id != psb.id AND p2.is_available = true AND p2.stock_quantity > 0 AND p2.price BETWEEN (psb.price * 0.8) AND (psb.price * 1.2) LIMIT 3) as similar_products,\n        CASE WHEN psb.discount_percentage > 0 THEN 'oferta' WHEN psb.price < (SELECT AVG(p3.price) * 0.9 FROM products p3 WHERE p3.category_id = psb.category_id AND p3.is_available = true) THEN 'buen_precio' WHEN psb.is_featured THEN 'destacado' ELSE 'normal' END as value_indicator,\n        CASE WHEN psb.stock_quantity > 10 THEN 'inmediato' WHEN psb.stock_quantity > 0 THEN 'disponible' ELSE 'consultar' END as availability_status\n    FROM product_search_base psb LEFT JOIN products p ON psb.id = p.id \n),\nranked_results AS (\n    SELECT *, ROW_NUMBER() OVER (ORDER BY CASE WHEN '{{$json.searchParams.urgency}}' = 'alta' THEN stock_quantity ELSE 0 END DESC, relevance_score DESC, CASE WHEN '{{$json.searchParams.orderBy}}' LIKE '%price_asc%' THEN price ELSE 0 END ASC, CASE WHEN '{{$json.searchParams.orderBy}}' LIKE '%price_desc%' THEN price ELSE 0 END DESC, is_featured DESC, popularity_score DESC, stock_quantity DESC, name ASC) as search_rank\n    FROM product_search_scored\n    WHERE relevance_score > 0 OR '{{$json.searchParams.searchType}}' IN ('featured_products', 'category_browse')\n)\nSELECT *,\n    CASE WHEN search_rank <= 3 THEN 'top_result' WHEN search_rank <= 8 THEN 'good_result' ELSE 'normal_result' END as result_quality,\n    CASE WHEN '{{$json.searchParams.servingSize}}' != '' THEN CASE WHEN weight_unit = 'kg' AND weight_value >= 1 THEN 1 WHEN weight_unit = 'g' AND weight_value <= 500 THEN CEIL(('{{$json.searchParams.servingSize}}')::decimal / 2) WHEN weight_unit = 'l' AND weight_value >= 1 THEN 1 ELSE 1 END ELSE 1 END as suggested_quantity\nFROM ranked_results\nORDER BY search_rank\nLIMIT (SELECT result_limit FROM search_config);",
        "options": {}
      },
      "id": "node_22_db_search_products",
      "name": "PostgreSQL - Search Products (Optimized) (Nodo 22)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.3,
      "position": [650, 300],
      "credentials": {
        "postgres": { "id": "postgres_creds", "name": "PostgreSQL" }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const items = $input.all();\nconst results = [];\nfunction formatProductDetails(product, searchParams) { return ''; }\nfunction generateSimilarSearchTerms(originalTerm) { return []; }\nfunction generateFooterText(products, searchParams, searchAnalysis) { return ''; }\nfor (const item of items) {\n    const session = item.json; \n    const products = session.products || []; \n    const searchParams = session.searchParams || {};\n    const searchAnalysis = session.searchAnalysis || {};\n    if (products.length === 0) {\n        let noResultsMessage = 'üòî *No encontr√© productos ';\n        let suggestions = [];\n        let alternativeSearches = [];\n        noResultsMessage += '\\n\\n';\n        if (searchParams.urgency === 'alta') noResultsMessage += '‚ö° *Como necesitas algo urgente*, te sugiero:';\n        else if (searchAnalysis.detectedBrand) noResultsMessage += `üè∑Ô∏è *No tenemos productos de ${searchAnalysis.detectedBrand}*, pero s√≠ tenemos alternativas de calidad.`;\n        else noResultsMessage += 'üí° *Quiz√°s te interese:*';\n        const response = { messageType: 'interactive', interactiveType: 'button', text: noResultsMessage, buttons: suggestions.slice(0, 3).map(s => ({ type: 'reply', reply: { id: s.id, title: s.title } })), footerText: 'Estamos aqu√≠ para ayudarte a encontrar lo que necesitas' };\n        results.push({ json: { ...session, responseReady: true, whatsappResponse: response, sessionUpdate: { session_state: 'no_results_found', context_data: JSON.stringify({ ...(session.context_data && typeof session.context_data === 'string' ? JSON.parse(session.context_data) : session.context_data || {}), lastSearchFailed: { params: searchParams, timestamp: new Date().toISOString(), suggestedAlternatives: alternativeSearches } }) } } });\n        continue;\n    }\n    const topResults = products.filter(p => p.result_quality === 'top_result');\n    const hasOffers = products.some(p => p.discount_percentage > 0);\n    const hasOutOfStock = products.filter(p => p.stock_status === 'sin_stock');\n    const availableProducts = products.filter(p => p.stock_status !== 'sin_stock');\n    let resultMessage = '';\n    const productRows = availableProducts.slice(0, 10).map(product => { return { id: `product_${product.id}`, title: `${product.name}${product.is_featured ? ' ‚≠ê':''}`, description: `Precio: ${product.price}`}; }); \n    const listSections = [];\n    if (availableProducts.length > 0) { listSections.push({title: 'Productos', rows: productRows}); } \n    const response = { messageType: 'interactive', interactiveType: 'list', text: resultMessage, buttonText: 'Seleccionar Producto', listSections: listSections, footerText: generateFooterText(products, searchParams, searchAnalysis) };\n    results.push({ json: { ...session, responseReady: true, whatsappResponse: response, sessionUpdate: { session_state: 'viewing_products', context_data: JSON.stringify({ ...(session.context_data && typeof session.context_data === 'string' ? JSON.parse(session.context_data) : session.context_data || {}), lastSearch: searchParams, productsShown: availableProducts.slice(0, 10).map(p => ({ id: p.id, name: p.name, price: p.price, stockStatus: p.stock_status, resultQuality: p.result_quality })), searchResultsCount: products.length, availableCount: availableProducts.length, outOfStockCount: hasOutOfStock.length, hasOffers: hasOffers, lastProductSearch: new Date().toISOString(), searchStrategy: searchParams.searchType, searchAnalysis: searchAnalysis }) } } });\n}\nreturn results;"
      },
      "id": "node_23_format_product_results",
      "name": "Format Product Results (Nodo 23)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const input = $input.item.json;\nconst eventStore = {\n  async recordEvent(event) {\n    const eventData = { id: 'uuid_placeholder', timestamp: new Date().toISOString(), aggregateId: event.customerId, eventType: event.type, payload: event.data, metadata: { sessionId: event.sessionId, nodeId: event.nodeId, workflowId: $workflow.id } };\n    console.log('Event Recorded:', eventData);\n  }\n};\nconst metrics = {\n  messageCounter: { inc: (labels) => console.log('Metric Incremented: ProductSearched', labels) }\n};\n\nawait eventStore.recordEvent({\n  type: 'ProductSearchExecuted',\n  customerId: input.session?.customer_phone,\n  data: { searchParams: input.searchParams, resultsCount: input.products?.length },\n  sessionId: input.session?.session_id,\n  nodeId: 'eventsource_metrics_product_search_f4',\n  workflowId: $workflow.id\n});\nmetrics.messageCounter.inc({ intent: input.searchParams?.searchType, status: 'success' });\nreturn input;"
      },
      "id": "eventsource_metrics_product_search_f4",
      "name": "EventSourcing & Metrics - Product Search",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [950, 450]
    }
  ],
  "connections": {
    "node_20_format_categories": {
      "main": [[{"node": "ml_predictor_node_f4", "type": "main", "index": 0}]]
    },
    "ml_predictor_node_f4": {
      "main": [[{"node": "node_21_prepare_product_search", "type": "main", "index": 0}]]
    },
    "node_21_prepare_product_search": {
      "main": [
        [
          {
            "node": "node_22_db_search_products",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "node_22_db_search_products": {
      "main": [
        [
          {
            "node": "node_23_format_product_results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "node_23_format_product_results": {
      "main": [[{"node": "eventsource_metrics_product_search_f4", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "errorWorkflow": "",
    "timezone": "America/Argentina/Buenos_Aires",
    "saveExecutionProgress": false,
    "saveManualExecutions": false,
    "callerPolicy": "workflowsFromSameAccount"
  },
  "staticData": null
}